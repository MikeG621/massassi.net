<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jon Hill">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Output Tutorial</TITLE>
</HEAD>
<BODY>
&nbsp;
<CENTER><TABLE BORDER=4 CELLSPACING=2 CELLPADDING=4 >
<CAPTION><B><U>Tutorial Information:</U></B></CAPTION>

<TR>
<TD>Tutorial Type:</TD>

<TD>COG programming - Output Functions</TD>
</TR>

<TR>
<TD>Target Audience:</TD>

<TD>Newbies, special interest in text output</TD>
</TR>

<TR>
<TD>Degree of Explanation:</TD>

<TD>detailed</TD>
</TR>

<TR>
<TD>Author Email:</TD>

<TD><A HREF="mailto:hill@golden.net">hill@golden.net</A></TD>
</TR>

<TR>
<TD>Dated:</TD>

<TD>June 5, 1998</TD>
</TR>
</TABLE></CENTER>
<B><U><FONT SIZE=+1></FONT></U></B>

<P><B><U><FONT SIZE=+1>1. What the heck am I reading?</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is a tutorial on formatting
text output generated by code in cogs.&nbsp; When I refer to output, I
am specifically referring to the yellow text lines which occur at the top
of the player screen during gameplay.&nbsp; The COG reference section in
JKSpecs version 0.3 refers very briefly to the commands associated with
output, but there isn't much explanation as to their function or use.&nbsp;
Through testing and debugging, I've got them all (well, all but two REALLY...but
they aren't important :-) figured out, so trust that everything I write
here has already been put to practical and successful use.
<BR>&nbsp;
<BR><B><U><FONT SIZE=+1>2. The forked path: the high and low road of putting
out</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There's two ways to
go about sending text or data to the player during run time: the Print()
series of commands and the jkString() series of commands.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Print() commands, though
simple, are also very inflexible in the way they are formatted.&nbsp; The
jkString() commands provide that flexibility by allowing you to build a
<B>string</B> from a bunch of sources, mixing text and numeric variables
all into one and spitting it out on the same line.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A "string" is just a fancy
way of saying "text" and includes most if not all ascii symbols, but it's
important to know that a string is only a "string" of "words" and can't
be used to do anything but make some kind of statement.&nbsp; A string
is only used to pass on information to the person sitting in front of the
computer screen, and doesn't store any information useful to the game itself.&nbsp;
For example, numbers in a string can't be used in calculations - the string
"4" has the same meaning to us people as the string&nbsp; "four", but is
not the same as the integer 4.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Strings are always surrounded
by quotation marks, so it's easy to distinguish between them.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An example of jkString formatting
might be:

<P>"<B>PLAYER_NAME</B> has <B>SCORE</B> kills and is <B>WINNING_OR_LOSING</B>"

<P>where PLAYER_NAME is an ascii variable depending on what that player's
name is for that game, SCORE is an integer representing that player's score,
and WINNING_OR_LOSING is either the word "winning" or "losing", depending
on how good that player's score is compared to everyone else's.&nbsp; All
the other text is pre-formatted and unchangeable, inserted to give sense
to the 3 variables in the line.&nbsp; We've also seen this type of formatting
when the familiar text goes "PLAYER_NAME has become more powerful than
he can possibly imagine."&nbsp; :-)

<P><B>Where to stick it...</B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Both methods of formatting
output place one line of ascii centered near the top of the screen in yellow
text.&nbsp; Exactly where the text is placed is related to whether there's
anything displayed there already.&nbsp; JK and MotS can only display 5
lines of text at a time, and each line is displayed for 5 seconds each<I>.</I>&nbsp;
So if there's already 2 lines of text at the top of the screen when either
a print() or jkStringOutput() is executed, this latest line of ascii will
be printed under the 2 existing lines of text until their time runs up.
<BR>&nbsp;
<BR><B><U><FONT SIZE=+1>3. Quick and Dirty, Harry</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print() commands are quick
and dirty, and are the simplest to use.&nbsp; Each Print() command in this
group is executed on a separate line, and are formatted "as is", centered
on that line.&nbsp; So for example, if the symbol SOME_NUMBER is equal
to 5, PrintInt(SOME_NUMBER), when executed, will print a lonely number
5, centered on it's own line at the top of the player screen.&nbsp; In
this family of commands are:
<BR>&nbsp;
<TABLE BORDER=4 CELLSPACING=2 CELLPADDING=4 WIDTH="100%" >
<CAPTION><B><U>Simple Output Formatting Functions</U></B></CAPTION>

<TR>
<TD>Print("string")</TD>

<TD>This simply prints whatever is between the quotations.</TD>
</TR>

<TR>
<TD>PrintInt(<B>int</B>)</TD>

<TD>This prints a single integer number.&nbsp; <B>Int</B> is any integer
number, or an integer defined symbol.</TD>
</TR>

<TR>
<TD>PrintFlex(<B>flex</B>)</TD>

<TD>This prints a single decimal number.&nbsp; <B>Flex</B> is any decimal
number or flex defined symbol.</TD>
</TR>

<TR>
<TD>PrintVector(<B>vector</B>)</TD>

<TD>The output of this command prints a set of 3 decimal numbers separated
by a space in the order x, y, z.&nbsp; <B>Vector</B> is a set of three
decimal numbers associated with defining movement, or some point in space,
usually referred to as x, y and z in that order.</TD>
</TR>

<TR>
<TD>jkPrintUNIString(<B>Int1</B>, <B>Int2</B>)&nbsp;</TD>

<TD>This prints a string stored in a UNI file.&nbsp;

<P><B>Int1</B> is an integer representing the player that the message will
be sent to.&nbsp; This is often set with a comand like GetLocalPlayerThing()
or GetSourceRef().&nbsp; This can also be a negative number representing
certain groups of players:

<P>(-3) here sends the message to the server AND all clients
<BR>(-2) sends only to the clients&nbsp;
<BR>(-1) sends only to the server.&nbsp;

<P>I'm positive about the (-3) meaning, but (-2) and (-1) meanings are
just my best guess.&nbsp;

<P><B>Int2</B> is a reference to the string found at that number's location
in a uni file.&nbsp;
<BR>** See section 5 near the end of this document for details on UNI strings.</TD>
</TR>
</TABLE>


<P>Examples of use in code and on the screen:

<P><B>Example 1:</B>
<BR>CODE:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Kyle!&nbsp; Get that
babelfish out of your ear!");

<P>RESULT:
<CENTER>&lt;top of screen></CENTER>

<CENTER>Kyle!&nbsp; Get that babelfish out of your ear!</CENTER>
&nbsp;

<P><B>Example 2:</B>
<BR>CODE:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("No the other one!&nbsp;
Can't you feel - naskoota wonkapee?&nbsp; Dah fit, dah fit.&nbsp; Dung
Jedi...");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printVector(vectorSet(3.2,
4.5, 2.0));

<P>RESULT:
<CENTER>&lt;top of screen></CENTER>

<CENTER>No the other one!&nbsp; Can't you feel - naskoota wonkapee?&nbsp;
Dah fit, dah fit.&nbsp; Dung Jedi...</CENTER>

<CENTER>3.200&nbsp; 4.500&nbsp; 2.000</CENTER>


<P><B><U><FONT SIZE=+1>4. JkString ... and what the heck is a concatanate?</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The jkString series of commands
store pieces of information in a buffer (that's like the imaginary place
where lost socks go, only you can find what's put in a buffer), which can
then be outputted as one line at the top of the screen.&nbsp; This process
of gluing bits of information together to make one string is called <B>concatanation</B>.&nbsp;
To concatanate something means to join it on at the <B>end</B> of something
else.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It's important to note
that a string is just a name for a grouping of letters and numbers, only
the numbers in a string have no "value" and as such can't be used in math
functions or to represent numerical data.&nbsp; Remember that a number
type symbol like an integer or a flex can be converted into a string, but
a string number can't be converted into a numerical value.&nbsp; (at least
not in JK...)

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKString commands require
a little more thought and a little more coding to make them work right.&nbsp;
It's a three step process:

<P>&nbsp;1. Clear the buffer of anything leftover from a previous use (neglecting
this can be a real pain in the&nbsp;&nbsp; buffer..)
<BR>&nbsp;2. Concatanate all your string bits
<BR>&nbsp;3. Chill and serve....I mean, send your buffered string to the
player's screen.

<P>&nbsp;The following is a list of all the jkString commands and commands
related to this method of output:
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER=4 CELLSPACING=2 CELLPADDING=4 WIDTH="100%" >
<CAPTION><B><U>jkString Output Formatting Functions</U></B></CAPTION>

<TR>
<TD>jkStringClear()</TD>

<TD>This clears the buffer, providing a blank space in which to create
our string.&nbsp; This should ALWAYS be executed before creating a string.</TD>
</TR>

<TR>
<TD>jkStringConcatAsciiString("string")</TD>

<TD>Similar to the Print("string") command, everything typed in quotations
will be concatanated to the end of the string in the buffer.</TD>
</TR>

<TR>
<TD>jkStringConcatInt(<B>int</B>)</TD>

<TD>This concatanates an <B>int</B>eger number or integer defined symbol
to the end of the string.</TD>
</TR>

<TR>
<TD>jkStringConcatFlex(<B>flex</B>)</TD>

<TD>This concatanates a <B>flex</B> number or flex defined symbol to the
end of the string.</TD>
</TR>

<TR>
<TD>jkStringConcatSpace()</TD>

<TD>Creates a black hole in the string.&nbsp;
<BR>I mean...&nbsp;
<BR>This adds a single empty space to the end of the string.&nbsp; Used
to separate concatanated pieces so they aren't all squished together.&nbsp;</TD>
</TR>

<TR>
<TD>jkStringConcatPlayerName(<B>int</B>)</TD>

<TD>This concatanates a player's name to the string.&nbsp; <B>Int</B> is
the ID number of a player in multiplayer, but the concatanate that will
be displayed, however, will be the actual player name, not the number.&nbsp;
The Id number is usually acquired using GetLocalPlayerThing() or get SourceRef()
or another function like that.</TD>
</TR>

<TR>
<TD>jkStringConcatVector(<B>vector</B>)</TD>

<TD>This concatanates a set of three decimal numbers to the string.&nbsp;
<B>Vector</B> represents a&nbsp; vector symbol or the use of VectorSet(flexX,
flexY, flexZ) to declare the vector.</TD>
</TR>

<TR>
<TD>jkStringConcatUNIString(<B>int</B>)</TD>

<TD>This function concatanates a UNI string stored in a uni file to the
currently buffered string.&nbsp; The <B>int</B>eger here represents the
ID number of a string stored in a UNI file, and concatanates that string
to the buffered string.
<BR>** See section 5 near the end of this document for details on UNI strings.</TD>
</TR>

<TR>
<TD>jkStringOutput(int1, int2)</TD>

<TD>This outputs the whole string currently stored in the jkString buffer
to the screen.&nbsp;<B></B>

<P><B>Int1</B> represents WHO receives the string.&nbsp; This can be the
ID number of a player, or in the case of a negative number, certain groups
of players.&nbsp; These numbers are the same as those used with jkPrintUniString().&nbsp;<B></B>

<P><B>Int2</B> is most often represented as a (-1) in LEC examples, and
as such, it is unknown at this time what it represents. I've tested this
command with different values, positive and negative, with no apparent
change in output.</TD>
</TR>
</TABLE>
&nbsp;
<BR><I>GENERAL EXAMPLE:</I>
<BR>CODE:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringClear();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatAsciiString("There
are");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatSpace();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatInt(3);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatAsciiString("
apples,");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatSpace();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatInt(2);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatSpace();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringConcatAsciiString("of
them are red.");
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jkStringOutput(-3, -1);
<BR>&nbsp;

<P>RESULT:
<CENTER>&lt;top of screen></CENTER>

<CENTER>There are 3 apples, 2 of them are red.</CENTER>


<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So if we had some code that
calculated the number of apples and another that calculated how many of
those are red, we could display those calcualations to the player in a
very comprehensive way.&nbsp; On a creative note, this is an excellent
way of creating special use cogs that can communicate useful data to the
player, like a rangefinder for example.&nbsp; Using jkString to format
output can be much more work than using simple print() commands, but the
results can also be much more meaningful and efficient.<B><U><FONT SIZE=+1></FONT></U></B>

<P><B><U><FONT SIZE=+1>5. UNI strings and other sexy underwear</FONT></U></B>
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Storing and calling strings
from UNI files is a very organized and efficient method of displaying output
to the screen, and has an added benefit as detailed in section 7 (don't
read it yet!&nbsp; I bet you just did, too...).&nbsp; What type of cog
you are creating determines which UNI file you need to store your string
in.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generally, UNI files store
and identify strings that will be displayed to the computer screen at some
point during the JK experience.&nbsp; These strings vary in purpose from
the text you see in all the game menus, to some of the yellow text that
appears at the top of the screen when playing the game.&nbsp; There are
a number of UNI files, each having at least one purpose - but for the sake
of cog coding, we only have to consider two such files:&nbsp; JKSTRINGS.UNI
and COGSTRINGS.UNI.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKSTRINGS.UNI stores strings
that are used in every <I>episode</I>, and for every time you run JK (or
MotS).&nbsp; This includes:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all menu text
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all keyboard command text,
viewable in the Setup/Control/Keyboard menu
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all cutscene text
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all UNI strings called by
cogs found in ITEMS.DAT
<BR>&nbsp;
<BR>...and some other not-so-important stuff :-)

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COGSTRINGS.UNI stores strings
that are used only in <I>specific</I> episodes (ie there is a different&nbsp;
cogstrings.uni file included with every different episode), and includes:
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all GOAL text for levels
in that episode
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all load-screen text for
levels in that episode
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all other cog-related UNI
strings for levels in that episode

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If your cog is linked to
any BIN (bins and their cogs are defined in ITEMS.DAT), then your UNI strings
called in that cog must be located in JKSTRINGS.UNI.&nbsp; An example of
this would be item_bacta.cog, which when activated prints:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Using Bacta"

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If, on the other hand, you
wanted to print a UNI string from a cog not found in ITEMS.DAT, that string
would have to be located in COGSTRINGS.UNI.&nbsp; For example, in the last
level of MotS, Kyle says:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "I know your intentions are
to save me, Mara... but it's far too late now."
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This string, used in a triggered-event
cog in the single player episode, is stored in the COGSTRINGS.UNI for that
episode.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cog strings are identified
and stored in a very specific way.&nbsp; Thankfully, the "specific way"
is essentially the same amongst all UNI files.&nbsp; Examine the following
taken from JKSTRINGS.UNI:

<P>&nbsp;"COG_00250"&nbsp;&nbsp;&nbsp; 0 "Using Bacta"

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There's three parts to this
line:
<BR>&nbsp;
<CENTER><TABLE BORDER=4 CELLSPACING=2 CELLPADDING=2 COLS=3 WIDTH="100%" >
<TR>
<TD>
<CENTER>"COG_00250"</CENTER>
</TD>

<TD>
<CENTER>0</CENTER>
</TD>

<TD>
<CENTER>"Using Bacta"</CENTER>
</TD>
</TR>

<TR>
<TD>
<CENTER>ID TAG</CENTER>
</TD>

<TD>
<CENTER>SPACER</CENTER>
</TD>

<TD>
<CENTER>STRING</CENTER>
</TD>
</TR>

<TR>
<TD>The ID tag for cog strings ALWAYS follows the format&nbsp;

<P>"COG_#####"

<P>&nbsp;where ##### is a five digit number that is unique for every string
in the file.&nbsp; This number is the integer that is used in the PrintUniString()
and jkStringConcatUNIString() to identify which UNI string to work with.</TD>

<TD>This is just a spacer.&nbsp; It has to be there, and is always just
a single, lonely 0 between the ID TAG and the STRING.</TD>

<TD>This is the text that we want to be associated with this particular
ID tag.</TD>
</TR>
</TABLE></CENTER>
&nbsp;

<P><B>Example:</B>
<BR>The following prints a string stored in JKSTRINGS.UNI from within the
activated: message of item_bacta.cog:

<P>CODE:
<BR>In JKSTRINGS.UNI:
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "COG_00<B>280</B>"&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp; "This is my very special text."

<P>In item_bacta.cog:

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Activated:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PrintUniString(-3, <B>280</B>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;=== no leading 0's required before 280
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
....

<P><I>OR</I>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Activated:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
jkStringClear();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
jkStringConcatUniString(<B>280</B>);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
jkStringOutput(-3,-1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
....

<P>RESULT:
<CENTER>&lt;top of screen></CENTER>

<CENTER>This is my very special text.</CENTER>


<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If this had been a brand
new cog, not defined in ITEMS.DAT, the string would have had to be stored
and ID'd in COGSTRINGS.UNI.

<P><B><U><FONT SIZE=+1>6. Size DOES matter: Making your text fit the screen</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Strings stored in a UNI file
and displayed using PrintUniString() or jkStringConcatUniString() can display
more characters on one line (longer line of text on screen) than a string
displayed by the print() verb or by a JKStringConcatAsciiString() in the
code itself.&nbsp; It seems the maximum CODED ascii string length is determined
by the screen resolution at the time the verb is executed.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For example:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A long string using print()
that is too long for 320x200 might show up in 640x480.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUT...

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A long string called from
a .UNI file with jkPrintUniString() (or jkStringConcatUniString()) will
<B>always</B> show up no matter how long the string is.&nbsp; If it is
TOO long for the screen width however, you will get some weird results
(Try playing "Siege at Vol Kanst" in 320x200 :-)

<P><B><U><FONT SIZE=+1>7. The End?&nbsp; Really?</FONT></U></B>

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I've left out two commands
on purpose - jkStringConcatFormattedInt(int1, int2) and jkStringConcatFormattedFlex(flex,
int).&nbsp; The reason is quite simple - I don't fully understand what
they do differently from jkStringConcatInt and ConcatFlex.&nbsp; I have
tested these thoroughly using various integer values for the second parameter
to no avail - differing numbers produce same results.&nbsp; It IS known
for sure that two arguments must be present and that the second argument
must be an integer, because in testing, omitting an argument forced a null
result from FormattedInt and a zero decimal zero result from formatted
flex.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maybe they posess the key
to unlocking all the cogging mysteries out there - but for now they're
not really all that important.

<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So, with that I bid you good
cogging and look forward to seeing some well versed and textually immaculate
cogs!

<P>______________
<BR><A HREF="mailto:hill@golden.net">MastaJedi</A>
<BR>Project Leader
<BR>JKRPG
<BR><A HREF="http://www.jedilegacy.net/SWRPG/">Jedi Knight Role Playing
Group Homepage</A>
<BR>&nbsp;
</BODY>
</HTML>
